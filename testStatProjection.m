function out= testStatProjection(grad,features1, features0, rho, nSim, useFeaturesMap1)
% test that the model lies in space spanned by features0 against an
% alterntaive that it lies in a space spanned by the union of features0 and features1.

% grad is the vector of pseudo residuals derived from the gradient
% e.g. grad = Y-X*beta_hat in linear model
% features0 is the matrix of features under the null (regressors under the
% null in linear model) where each column is a different feature;
% features1 is the matrix of features to test the alternative 
% (regressors not included in the null model when using a linear model);
% rho is the penalty used to compute the projection of features1 on features0
% using ridge regression;
% nSim is the number of simulations to compute the critical values;
% useFeaturesMap1 = 1 if want to use the featuresMap of the 
% reproducing kernel Hilbert space generated by the kernel features1*features1'. 

% out is teststat and p-value

% basic use: out = testStatProjection(grad,features1, features0)

% For more details:
% Sancetta, A. (2017) Inference for Additive Models in the Presence of Possibly
% Infinite Dimensional Nuisance Parameters. URL:https://arxiv.org/abs/1611.02199


if nargin <5
   
    nSim     = 100000;
    
end


if nargin <6
    useFeaturesMap1  = 0;
end
n         = size(grad,1);

rootn        = sqrt(n);

if nargin <4
   %for finite dimensional feature space choose rho=0 or small rho; but do
   %use generalized inverse.
    rho     = 0;% .01*log(n)/rootn; use suggested non-zero rho or high dimensional cases
                
end

% include an intercept in null features when projecting the alternative
% features: comment out this line if needed.
features0    = [ones(n,1), features0];


[n,K0]    = size(features0);

ZZ            = (rho*eye(K0))+(features0'*features0/n);
ZX            = features0'*features1/n;

% compute residual instruments 
% using pseudo inverse: particularly important when rho is set to zero
h1            = features1 - features0*pinv(ZZ)*ZX;

if useFeaturesMap1 ==1 % this option tends to have more power against nonlinear alternatives
    %use the covariance kernel as instrument, but standardize so that it has
    %unit norm
    C1            = bsxfun(@rdivide, features1 , sqrt(sum(features1 .^2,2))); 

    if n> 100 % only extract 100 functions: change this some larger number to increase power
        ind           = rand(n,1)<=100/n;
    else

        ind       = true(n,1);
    end
    h1            = h1*C1(ind,:)';
end

S             = bsxfun(@times, grad-mean(grad),h1);
% compute var of test stat
varS          = var(grad)*(h1'*h1/n);

% compte test stat
testStat     = sum(sum(S/rootn).^2);
% simulate process under the null
Z            = get_simulateUnstandardizedChiSquare(nSim,varS, 1);
% find pvalues from empirical distribution
pVal         = 1-get_ecdf(Z,testStat);

out          = [testStat , pVal];


end


function out = get_simulateUnstandardizedChiSquare(n,covX, thresh)
% simulate the limiting process under the null
if nargin <3
   
    thresh        = .999;
    
end

[V, D]            = eig(covX);
[D, order]        = sort(real(diag(D)),'descend');  

csumD             = cumsum(D)/sum(D);
p                 = sum(csumD<=thresh);

Z2                = normrnd(zeros(n*p,1),1).^2;
Z2                = reshape(Z2,n,p);
out               = Z2*D(1:p);


end


function out = get_ecdf(X,evalX)
% the empirical p-value
n            = size(X,1);
out          = bsxfun(@le, X',evalX);
out          = sum(out,2)/n;


end





